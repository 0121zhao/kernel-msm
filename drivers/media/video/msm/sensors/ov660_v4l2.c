/*
 * Copyright (C) 2013, Motorola Mobility LLC
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
#include "ov660_v4l2.h"
#include <linux/i2c.h>

#define OV660_CHIP_ID_ADDR 0x6080
#define OV660_CHIP_ID_DATA 0x0660

struct ov660_data_t {
	struct i2c_client *client;
};
static struct ov660_data_t *ov660_data;

static int ov660_write_i2c(uint16_t addr, uint8_t data)
{
	int32_t rc = 0;
	uint8_t buf[3];
	struct i2c_msg msg = {
		.addr = ov660_data->client->addr,
		.flags = 0,
		.buf = buf,
		.len = 3, };

	buf[0] = addr >> 8;
	buf[1] = (addr & 0x00FF);
	buf[2] = data;

	pr_debug("%s: Address: 0x%x%x Data: %x\n", __func__,
			buf[0], buf[1], buf[2]);

	if (ov660_data && ov660_data->client) {
		rc = i2c_transfer(ov660_data->client->adapter, &msg, 1);
		if (rc < 0)
			pr_err("%s: i2c transfer error (%d)\n", __func__, rc);
	}

	return rc;
}

static int ov660_read_i2c(uint16_t addr, uint8_t *data, int data_length)
{
	int32_t rc = -EFAULT;
	uint8_t buf[4];
	uint16_t saddr;
	struct i2c_msg msgs[2];

	if (ov660_data && ov660_data->client) {
		saddr = ov660_data->client->addr;
		msgs[0].addr = saddr;
		msgs[0].flags = 0;
		msgs[0].len = 2;
		msgs[0].buf = buf;

		msgs[1].addr = saddr;
		msgs[1].flags = I2C_M_RD;
		msgs[1].len = data_length;
		msgs[1].buf = data;

		buf[0] = addr >> 8;
		buf[1] = (addr & 0x00FF);

		rc = i2c_transfer(ov660_data->client->adapter, msgs, 2);
		if (rc < 0)
			pr_err("%s: error writing i2c (%d)\n",
						__func__, rc);
	}
	return rc;
}
static int ov660_write_i2c_tbl(struct ov660_reg_i2c_tbl *in_table,
		uint16_t size)
{
	int i;
	int32_t rc = -EFAULT;

	for (i = 0; i < size; i++) {
		rc = ov660_write_i2c(in_table->reg_addr, in_table->reg_data);
		in_table++;
	}
	return rc;
}

/* This function replaces the current probe since the power up
 * sequence and power down sequence is tied to the camera driver
 * it self. The camera being used will see if the ov660 is
 * active by calling this probe function */
int32_t ov660_check_probe(void)
{
	int rc = 0;
	uint8_t data[2];
	uint8_t *data_ptr = data;

	/* Need to make sure we are talking to the right device since
	 * there is no other code to check the id of the part */
	ov660_read_i2c(OV660_CHIP_ID_ADDR, data_ptr, 2);

	/* Now checking to see if we match the correct chip id */
	if ((data[0] << 8 | data[1]) == OV660_CHIP_ID_DATA) {
		pr_info("%s: successful\n", __func__);
	} else {
		pr_err("%s: does not exist! with return value %x\n", __func__,
				(data[0] << 8 | data[1]));
		rc = -ENODEV;
	}

	return rc;
}

static int ov660_probe(struct i2c_client *client,
		const struct i2c_device_id *id)
{
	int rc = 0;

	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		rc = -ENODEV;
		dev_err(&client->dev, "client not i2c capable\n");
		return rc;
	}

	ov660_data = kzalloc(sizeof(struct ov660_data_t), GFP_KERNEL);
	if (ov660_data == NULL) {
		rc = -ENOMEM;
		dev_err(&client->dev, "kzalloc failed\n");
		return rc;
	}

	ov660_data->client = client;
	i2c_set_clientdata(client, ov660_data);

	pr_info("%s: successful!\n", __func__);
	return rc;
}

static int ov660_remove(struct i2c_client *client)
{
	kfree(ov660_data);
	ov660_data = NULL;
	return 0;
}

static const struct i2c_device_id ov660_id[] = {
	{OV660_NAME, 0},
	{}
};

MODULE_DEVICE_TABLE(i2c, ov660_id);

static struct i2c_driver ov660_i2c_driver = {
	.probe = ov660_probe,
	.remove = ov660_remove,
	.id_table = ov660_id,
	.driver = {
		.name = OV660_NAME,
		.owner = THIS_MODULE,
	},
};

static int __init ov660_init(void)
{
	return i2c_add_driver(&ov660_i2c_driver);
}

static void __init ov660_exit(void)
{
	i2c_del_driver(&ov660_i2c_driver);
}


static struct ov660_reg_i2c_tbl ov660_ov8835_init_settings[] = {
	{0x6b00, 0x10},
	{0x6103, 0x20},
	{0x6010, 0xff},
	{0x6011, 0xff},
	{0x6012, 0xff},
	{0x6013, 0xff},
	{0x6014, 0xff},
	{0x6008, 0x00},
	{0x6009, 0x00},
	{0x600a, 0x00},
	{0x600b, 0x00},
	{0x600c, 0x00},
	{0x600d, 0x00},
	{0x600e, 0x00},
	{0x6021, 0x38},
	{0x6026, 0x56},
	{0x6814, 0x10},
	{0x6813, 0x02},
	{0x6805, 0x08},
	{0x680c, 0x0c},
	{0x6822, 0x4f},
	{0x6204, 0x0c},
	{0x6284, 0x08},
	{0x6410, 0x28},
	{0x6424, 0x01},
	{0x6333, 0x60},
	{0x6310, 0x0c},
	{0x6311, 0xc0},
	{0x6312, 0x09},
	{0x6313, 0x90},
	{0x6314, 0x0c},
	{0x6315, 0xc0},
	{0x6316, 0x09},
	{0x6317, 0x90},
	{0x6318, 0x00},
	{0x6319, 0x00},
	{0x631a, 0x00},
	{0x631b, 0x00},
	{0x6300, 0x0c},
	{0x6301, 0xc0},
	{0x6302, 0x09},
	{0x6303, 0x90},
	{0x6819, 0x0c},
	{0x681a, 0xc0},
	{0x681b, 0x09},
	{0x681c, 0x90},
	{0x6815, 0x80},
	{0x6817, 0x2b},
	{0x620f, 0xab},
	{0x628f, 0xab},
	{0x6204, 0x0c},
	{0x6402, 0x02},
	{0x6400, 0x88},
	{0x6404, 0xa4},
	{0x601b, 0x01},
	{0x6823, 0x0f},
	{0x6702, 0x02},
	{0x6106, 0x40},
	{0x7009, 0x14},
	{0x7011, 0x20},
	{0x7013, 0x10},
	{0x701e, 0x0c},
	{0x701f, 0xbf},
	{0x7020, 0x09},
	{0x7021, 0x8f},
	{0x7002, 0x15},
	{0x7004, 0x00},
	{0x7003, 0x10},
	{0x7041, 0x00},
	{0x7000, 0x40},
	{0x704f, 0x10},
	{0x7082, 0x00},
	{0x7182, 0x07},
	{0x7183, 0x87},
	{0x7184, 0x05},
	{0x7185, 0x05},
	{0x7186, 0x07},
	{0x7187, 0x87},
	{0x7188, 0x05},
	{0x7189, 0x05},
	{0x7110, 0x40},
	{0x7111, 0x20},
	{0x634e, 0x40},
};

static struct ov660_reg_i2c_tbl ov660_ov10820_init_settings[] = {
	{0x6b00, 0x10},
	{0x6103, 0x20},
	{0x6010, 0xff},
	{0x6011, 0xff},
	{0x6012, 0xff},
	{0x6013, 0xff},
	{0x6014, 0xff},
	{0x6008, 0x00},
	{0x6009, 0x00},
	{0x600a, 0x00},
	{0x600b, 0x00},
	{0x600c, 0x00},
	{0x600d, 0x00},
	{0x600e, 0x00},
	{0x6021, 0x7a},
	{0x6026, 0x56},
	{0x60a0, 0x15},
	{0x6814, 0x0f},
	{0x6813, 0x03},
	{0x6805, 0x08},
	{0x680c, 0x0c},
	{0x6822, 0x4f},
	{0x6204, 0x0c},
	{0x6284, 0x08},
	{0x6410, 0x28},
	{0x6424, 0x01},
	{0x6333, 0x60},
	{0x6310, 0x10},
	{0x6311, 0xe0},
	{0x6312, 0x09},
	{0x6313, 0x80},
	{0x6314, 0x10},
	{0x6315, 0xe0},
	{0x6316, 0x09},
	{0x6317, 0x80},
	{0x6318, 0x00},
	{0x6319, 0x00},
	{0x631a, 0x00},
	{0x631b, 0x00},
	{0x6300, 0x10},
	{0x6301, 0xe0},
	{0x6302, 0x09},
	{0x6303, 0x80},
	{0x6819, 0x10},
	{0x681a, 0xe0},
	{0x681b, 0x09},
	{0x681c, 0x80},
	{0x6815, 0x80},
	{0x6817, 0x2b},
	{0x620f, 0xab},
	{0x628f, 0xab},
	{0x6204, 0x0c},
	{0x6402, 0x02},
	{0x6400, 0x88},
	{0x6404, 0xa4},
	{0x601b, 0x01},
	{0x6823, 0x0f},
	{0x6702, 0x02},
	{0x6106, 0x40},
	{0x7009, 0x14},
	{0x7011, 0x40},
	{0x7013, 0x40},
	{0x701e, 0x10},
	{0x701f, 0xdf},
	{0x7020, 0x09},
	{0x7021, 0x7f},
	{0x7001, 0xe0},
	{0x7002, 0x15},
	{0x7003, 0x11},
	{0x7004, 0x01},
	{0x7006, 0x03},
	{0x7041, 0x00},
	{0x7000, 0x40},
	{0x704f, 0x11},
	{0x7082, 0x00},
	{0x7182, 0x07},
	{0x7183, 0x87},
	{0x7184, 0x05},
	{0x7185, 0x05},
	{0x7186, 0x07},
	{0x7187, 0x87},
	{0x7188, 0x05},
	{0x7189, 0x05},
	{0x7110, 0x40},
	{0x7111, 0x20},
	{0x634e, 0x40},
};

static struct ov660_reg_i2c_tbl ov660_ov10820_blc_work_around_settings[] = {
	{0x7012, 0x00},
	{0x7013, 0x00},
};

static struct ov660_reg_i2c_tbl ov660_ov10820_lsc_settings[] = {
	{0x7200, 0xa8},
	{0x7201, 0x6f},
	{0x7202, 0x57},
	{0x7203, 0x4d},
	{0x7204, 0x4f},
	{0x7205, 0x59},
	{0x7206, 0x71},
	{0x7207, 0xad},
	{0x7208, 0x34},
	{0x7209, 0x28},
	{0x720a, 0x20},
	{0x720b, 0x1e},
	{0x720c, 0x1e},
	{0x720d, 0x21},
	{0x720e, 0x29},
	{0x720f, 0x36},
	{0x7210, 0x1b},
	{0x7211, 0x13},
	{0x7212, 0x0d},
	{0x7213, 0x0a},
	{0x7214, 0x0b},
	{0x7215, 0x0e},
	{0x7216, 0x14},
	{0x7217, 0x1d},
	{0x7218, 0x10},
	{0x7219, 0x08},
	{0x721a, 0x02},
	{0x721b, 0x00},
	{0x721c, 0x00},
	{0x721d, 0x03},
	{0x721e, 0x0a},
	{0x721f, 0x13},
	{0x7220, 0x0f},
	{0x7221, 0x07},
	{0x7222, 0x02},
	{0x7223, 0x00},
	{0x7224, 0x00},
	{0x7225, 0x03},
	{0x7226, 0x0a},
	{0x7227, 0x12},
	{0x7228, 0x18},
	{0x7229, 0x10},
	{0x722a, 0x0a},
	{0x722b, 0x08},
	{0x722c, 0x09},
	{0x722d, 0x0c},
	{0x722e, 0x12},
	{0x722f, 0x1b},
	{0x7230, 0x2f},
	{0x7231, 0x24},
	{0x7232, 0x1d},
	{0x7233, 0x1a},
	{0x7234, 0x1b},
	{0x7235, 0x1f},
	{0x7236, 0x26},
	{0x7237, 0x32},
	{0x7238, 0x8a},
	{0x7239, 0x5e},
	{0x723a, 0x48},
	{0x723b, 0x42},
	{0x723c, 0x42},
	{0x723d, 0x4a},
	{0x723e, 0x61},
	{0x723f, 0x8d},
	{0x7240, 0x9f},
	{0x7241, 0x95},
	{0x7242, 0x93},
	{0x7243, 0x93},
	{0x7244, 0x93},
	{0x7245, 0x94},
	{0x7246, 0x98},
	{0x7247, 0x9e},
	{0x7248, 0x93},
	{0x7249, 0x90},
	{0x724a, 0x8f},
	{0x724b, 0x8e},
	{0x724c, 0x8f},
	{0x724d, 0x90},
	{0x724e, 0x92},
	{0x724f, 0x95},
	{0x7250, 0x91},
	{0x7251, 0x8a},
	{0x7252, 0x88},
	{0x7253, 0x87},
	{0x7254, 0x88},
	{0x7255, 0x8a},
	{0x7256, 0x8d},
	{0x7257, 0x93},
	{0x7258, 0x8d},
	{0x7259, 0x88},
	{0x725a, 0x83},
	{0x725b, 0x80},
	{0x725c, 0x80},
	{0x725d, 0x83},
	{0x725e, 0x88},
	{0x725f, 0x8e},
	{0x7260, 0x90},
	{0x7261, 0x8a},
	{0x7262, 0x84},
	{0x7263, 0x80},
	{0x7264, 0x80},
	{0x7265, 0x83},
	{0x7266, 0x87},
	{0x7267, 0x8d},
	{0x7268, 0x99},
	{0x7269, 0x90},
	{0x726a, 0x8d},
	{0x726b, 0x8a},
	{0x726c, 0x89},
	{0x726d, 0x89},
	{0x726e, 0x8c},
	{0x726f, 0x92},
	{0x7270, 0x9e},
	{0x7271, 0x98},
	{0x7272, 0x95},
	{0x7273, 0x94},
	{0x7274, 0x92},
	{0x7275, 0x92},
	{0x7276, 0x94},
	{0x7277, 0x96},
	{0x7278, 0xb4},
	{0x7279, 0xa7},
	{0x727a, 0xa8},
	{0x727b, 0xa1},
	{0x727c, 0xa0},
	{0x727d, 0xa4},
	{0x727e, 0xa3},
	{0x727f, 0xb3},
	{0x7280, 0x9d},
	{0x7281, 0x95},
	{0x7282, 0x92},
	{0x7283, 0x93},
	{0x7284, 0x91},
	{0x7285, 0x92},
	{0x7286, 0x97},
	{0x7287, 0x9f},
	{0x7288, 0x94},
	{0x7289, 0x90},
	{0x728a, 0x8f},
	{0x728b, 0x8e},
	{0x728c, 0x8f},
	{0x728d, 0x91},
	{0x728e, 0x92},
	{0x728f, 0x94},
	{0x7290, 0x92},
	{0x7291, 0x8a},
	{0x7292, 0x88},
	{0x7293, 0x87},
	{0x7294, 0x88},
	{0x7295, 0x8a},
	{0x7296, 0x8d},
	{0x7297, 0x92},
	{0x7298, 0x8d},
	{0x7299, 0x88},
	{0x729a, 0x83},
	{0x729b, 0x80},
	{0x729c, 0x80},
	{0x729d, 0x83},
	{0x729e, 0x88},
	{0x729f, 0x8c},
	{0x72a0, 0x90},
	{0x72a1, 0x8b},
	{0x72a2, 0x84},
	{0x72a3, 0x81},
	{0x72a4, 0x80},
	{0x72a5, 0x82},
	{0x72a6, 0x87},
	{0x72a7, 0x8b},
	{0x72a8, 0x99},
	{0x72a9, 0x91},
	{0x72aa, 0x8e},
	{0x72ab, 0x8a},
	{0x72ac, 0x89},
	{0x72ad, 0x8a},
	{0x72ae, 0x8c},
	{0x72af, 0x91},
	{0x72b0, 0x9e},
	{0x72b1, 0x98},
	{0x72b2, 0x94},
	{0x72b3, 0x94},
	{0x72b4, 0x93},
	{0x72b5, 0x92},
	{0x72b6, 0x94},
	{0x72b7, 0x95},
	{0x72b8, 0xb0},
	{0x72b9, 0xa5},
	{0x72ba, 0xa6},
	{0x72bb, 0xa0},
	{0x72bc, 0x9e},
	{0x72bd, 0xa2},
	{0x72be, 0xa1},
	{0x72bf, 0xaf},
	{0x72c0, 0x9c},
	{0x72c1, 0x96},
	{0x72c2, 0x93},
	{0x72c3, 0x93},
	{0x72c4, 0x92},
	{0x72c5, 0x93},
	{0x72c6, 0x97},
	{0x72c7, 0x9d},
	{0x72c8, 0x94},
	{0x72c9, 0x90},
	{0x72ca, 0x90},
	{0x72cb, 0x8f},
	{0x72cc, 0x90},
	{0x72cd, 0x92},
	{0x72ce, 0x94},
	{0x72cf, 0x95},
	{0x72d0, 0x93},
	{0x72d1, 0x8b},
	{0x72d2, 0x89},
	{0x72d3, 0x88},
	{0x72d4, 0x89},
	{0x72d5, 0x8a},
	{0x72d6, 0x8e},
	{0x72d7, 0x92},
	{0x72d8, 0x8e},
	{0x72d9, 0x89},
	{0x72da, 0x83},
	{0x72db, 0x80},
	{0x72dc, 0x7f},
	{0x72dd, 0x83},
	{0x72de, 0x88},
	{0x72df, 0x8d},
	{0x72e0, 0x91},
	{0x72e1, 0x8c},
	{0x72e2, 0x85},
	{0x72e3, 0x81},
	{0x72e4, 0x80},
	{0x72e5, 0x83},
	{0x72e6, 0x87},
	{0x72e7, 0x8b},
	{0x72e8, 0x9c},
	{0x72e9, 0x92},
	{0x72ea, 0x90},
	{0x72eb, 0x8c},
	{0x72ec, 0x8a},
	{0x72ed, 0x8a},
	{0x72ee, 0x8c},
	{0x72ef, 0x91},
	{0x72f0, 0x9e},
	{0x72f1, 0x9a},
	{0x72f2, 0x96},
	{0x72f3, 0x94},
	{0x72f4, 0x92},
	{0x72f5, 0x92},
	{0x72f6, 0x93},
	{0x72f7, 0x93},
	{0x72f8, 0xaf},
	{0x72f9, 0xa2},
	{0x72fa, 0xa6},
	{0x72fb, 0xa1},
	{0x72fc, 0xa0},
	{0x72fd, 0xa1},
	{0x72fe, 0x9e},
	{0x72ff, 0xac},
};

int32_t ov660_intialize_10MP(void)
{
	int32_t rc = 0;
	pr_debug("%s: enter\n", __func__);
	rc = ov660_write_i2c_tbl(ov660_ov10820_init_settings,
			ARRAY_SIZE(ov660_ov10820_init_settings));

	if (rc < 0) {
		pr_err("%s: unable to write the init settings\n", __func__);
		goto initialize_done;
	}

	rc = ov660_write_i2c_tbl(ov660_ov10820_lsc_settings,
			ARRAY_SIZE(ov660_ov10820_lsc_settings));
	if (rc < 0) {
		pr_err("%s: unable to write the lsc settings\n", __func__);
		goto initialize_done;
	}

	rc = ov660_write_i2c_tbl(ov660_ov10820_blc_work_around_settings,
			ARRAY_SIZE(ov660_ov10820_blc_work_around_settings));
	if (rc < 0) {
		pr_err("%s: unable to write blc work around\n", __func__);
		goto initialize_done;
	}

initialize_done:
	pr_debug("%s: exit\n", __func__);
	return rc;
}

int32_t ov660_intialize_8MP(void)
{
	int32_t rc = 0;
	rc = ov660_write_i2c_tbl(ov660_ov8835_init_settings,
			ARRAY_SIZE(ov660_ov8835_init_settings));

	return rc;
}

module_init(ov660_init);
module_exit(ov660_exit);

MODULE_DESCRIPTION("ASIC driver for 8 and 10 MP RGBC Cameras");
MODULE_AUTHOR("MOTOROLA");
MODULE_LICENSE("GPL");


